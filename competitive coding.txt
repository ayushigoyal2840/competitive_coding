Q1)count number of set bits between given range of numbers
sol)
#include<bits/stdc++.h>
#define ll long long int
using namespace std;
int countset(int n)
{
	int count =0;
	while(n>0)
	{
		count+=(n&1);
		n=n>>1;
	}
	return count;
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	ll t;
	cin>>t;
	while(t--)
	{
		int a,b;
		cin>>a>>b;
		int count=0;
		for(int i=a;i<=b;i++)
		{
			if((i&1)==0 && i<b)
			{
				count+=2*countset(i)+1;
				i++;
				continue;
			}
			count+=countset(i);
		}
		cout<<count;
		}	
}
Q2)Input Format

A single integer, .

Constraints

Subtasks

 for  of the maximum score.
Output Format

Print the total number of integers  satisfying the criteria.

Sample Input 0

5
Sample Output 0

2
(5+2=5xor2)

sol)
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    long long n;
    cin>>n;
    long long count =0;
    long long i=0;
    while(i<=n)
    {
        long long m=(n ^ i);
        if(m==(n+i))
        {
            count+=1;
            
        }
        i++;
    }
    cout<<count<<endl;
    return 0;
}
Q3)nput Format

The first line contains a single integer, , denoting the number of integers in the array.
The second line contains  space-separated integers describing the values in .

Constraints

It is guaranteed that  is an odd number and that there is one unique element.
, where .
Output Format

Print the unique integer in the array.


sol)
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int n;
    cin>>n;
    int arr[100];
    int m;
    for(int i=0;i<n;i++)
    {
        cin>>arr[i];
        m=arr[0];
    }
    for(int i=1;i<n;i++)
    {
        m=(m ^ arr[i]);
    }
    cout<<m<<endl;
    return 0;
    
}

Q4)
Input Format

The first line contains the integer .
The second line contains the integer .

Constraints

3

Output Format

Return the maximal value of the xor operations for all permutations of the integers from l to r, inclusive.

sol)
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int l,r;
    cin>>l>>r;
    int max=0;
    for(int i=l;i<=r;i++)
    {
        for(int j=i;j<=r;j++)
        {
            int a = (i ^ j);
            if(a>max)
            max=a;
        }
    }
    cout<<max<<"\n";
    return 0;
}


Q5)lucky number 
we have to find he index of lucky number using bit manipulation

in this program we have we have used the algorithm of formula
2(2(pow x)-1)/2-1=2(pow x)-2=(1<<x)-2
we can write 2 raised to the power x as (1<<x)

sol)

#include<bits/stdc++.h>
using namespace std;
int main()
{
	char arr[20];
	cin>>arr;
	long long digits=strlen(arr);
	long long ans=0;
	ans=(1<<digits)-2;
	for(long long i=digits-1,count=0;i>=0;i--,count++)
	{
		if(arr[i]=='7')
		ans+=(1<<count);
	}
	cout<<(ans+1)<<"\n";
	
	return 0;
}

Q6)
array={1,2,3,3};
query={3,5,7,20};

for each query output the subset sum using bitwise manipulations.

sol)
approach to this problem can be using bitset 
bitset<10>b; then we can itialize it with zeroes.
then we will take an empty array arr={0};
we will set last bit as 1 which means we can create subset sum with every element;
then we left with the bitset by first array element
then we can do b|=(b<<arr[0])
this means now we can create sum of 0 and 1
then we will do left shift of bitset by second element
if we get 1 then it means we can get subset with that respective element
after traversing alll the elements of array our bitset will become 111111111
``````b|=(b<<arr[i])``````
now we will see handling queries
our queries array was={3,5,7,20}
now we will see that if(b[q[i]]==1)
return 1;
esle
return 0;


program->
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int arr[]={1,2,3,4};
	int q[]={3,5,7,20};
	bitset <10> b;
	b[0]=1;
	for(int i=0;i<4;i++)
	{
		b|=(b<<arr[i]);
		cout<<b<<"\n";
	}
	for(int i=0;i<4;i++)
	{
		cout<<q[i]<<"->";
		if(b[q[i]])
		cout<<"subset sum exits \n";
		else
		cout<<"no";
	}
	return 0;
}



Q7)Kadane's Algorithm
a={1,-2,-1,5,-1,0,-1,7}
we will have to find i j such that a[i]+....a[j]=max sum possible

first we have to initialise two elements first is a[0]=max-till =1    a[0]=current-max=1

#include<bits/stdc++.h>
using namespace std;
int main()
{
	int arr[]={1,-2,-1,5,-1,0,-1,7};
	int n=sizeof(arr)/sizeof(arr[0]);
	int max_till=arr[0];
	int current_max=arr[0];
	for(int i=1;i<n;i++)
	{
		current_max=max(arr[i],current_max+arr[i]);
		max_till=max(max_till, current_max);
	}
	cout<<max_till<<"\n";
	return 0;
}


Q8)
A. Flipping Game
time limit per test1 second
memory limit per test256 megabytes
inputstandard input
outputstandard output
Iahub got bored, so he invented a game to be played on paper.

He writes n integers a1, a2, ..., an. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices i and j (1 ≤ i ≤ j ≤ n) and flips all values ak for which their positions are in range [i, j] (that is i ≤ k ≤ j). Flip the value of x means to apply operation x = 1 - x.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.

Input
The first line of the input contains an integer n (1 ≤ n ≤ 100). In the second line of the input there are n integers: a1, a2, ..., an. It is guaranteed that each of those n values is either 0 or 1.

Output
Print an integer — the maximal number of 1s that can be obtained after exactly one move.

Examples
inputCopy
5
1 0 0 1 0
outputCopy
4
inputCopy
4
1 0 0 1
outputCopy
4
Note
In the first case, flip the segment from 2 to 5 (i = 2, j = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (i = 2, j = 3) will turn all numbers into 1.



sol)


Q9)

Q10)

Q11)
























